using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.FileProviders;
using VueJSMVCDotNet.Handlers;
using VueJSMVCDotNet.Handlers.Model;
using VueJSMVCDotNet.Interfaces;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using Microsoft.Extensions.Caching.Memory;

namespace VueJSMVCDotNet
{
    /// <summary>
    /// Used to supply the additional components for the VueModelsHandler
    /// </summary>
    public class VueModelsOptions
    {
        /// <summary>
        /// The Secure Session Factory builder
        /// </summary>
        public ISecureSessionFactory SessionFactory { get; init; }
        /// <summary>
        /// Options: This will remap all urls provided in attributes to the base path provided (e.g. "/modules/tester/")
        /// </summary>
        public string BaseURL { get; init; } = null;
        /// <summary>
        /// Optional: If flagged as true it will ignore/disable invalid models
        /// </summary>
        public bool IgnoreInvalidModels { get; init; } = false;
        /// <summary>
        /// Optional:  A list of header keys to read from and write to for all requests if using headers for security
        /// </summary>
        public string[] SecurityHeaders { get; init; } = null;
    }

    /// <summary>
    /// Used to supply the additional components for the MessagesHandler
    /// </summary>
    /// 
    public class MessageHandlerOptions
    {
        /// <summary>
        /// The base url for the messages to exist inside
        /// </summary>
        public string BaseURL { get; init; }
    }

    /// <summary>
    /// Used to supply the additional components for the VueFilesHandler
    /// </summary>
    /// 
    public class VueFilesHandlerOptions
    {
        /// <summary>
        /// The base url for the messages to exist inside
        /// </summary>
        public string BaseURL { get; init; }
    }

    /// <summary>
    /// Used to supply the additional configurations for the different middleware components
    /// </summary>
    public class VueMiddlewareOptions
    {
        /// <summary>
        /// Optional: An instance of a log writer class to write the logging information to
        /// </summary>
        public ILogger LogWriter { get; init; } = null;
        /// <summary>
        /// Optional: The import path for the VueJs library: default="https://unpkg.com/vue@3/dist/vue.runtime.esm-browser.prod.js"
        /// </summary>
        public string VueImportPath { get; init; } = "https://unpkg.com/vue@3/dist/vue.runtime.esm-browser.prod.js";
        /// <summary>
        /// Optional: The import path for the Vue-Loader library: default="https://unpkg.com/vue3-sfc-loader@0.8.4/dist/vue3-sfc-loader.esm.js"
        /// </summary>
        public string VueLoaderImportPath { get; init; } = "https://unpkg.com/vue3-sfc-loader@0.8.4/dist/vue3-sfc-loader.esm.js";
        /// <summary>
        /// Optional: This will remap the core JS url that is imported by all classes to a different path
        /// </summary>
        public string CoreJSURL { get; init; } = "/VueJSMVCDotNet_core.min.js";
        /// <summary>
        /// Optional:  This will change the import call from the core js url to the module name
        /// </summary>
        public string CoreJSImport { get; init; } = null;
        /// <summary>
        /// An instance of a file provider, required if using VueFiles or Messages
        /// </summary>
        public IFileProvider FileProvider { get; init; } = null;
        /// <summary>
        /// Optional: must be provided in order to use the IModel and autogenerated Models/Rest interfaces
        /// </summary>
        public VueModelsOptions VueModelsOptions { get; init; } = null;
        /// <summary>
        /// Optional: to be provided if the message translator component is to be used
        /// </summary>
        public MessageHandlerOptions MessageOptions { get; init; } = null;
        /// <summary>
        /// Optional: Settings to be used file the Vue File handler
        /// </summary>
        public VueFilesHandlerOptions VueFilesOptions { get; init; } = null;
        /// <summary>
        /// Optional: If set to true this will compress all outputted javascript, whether or not the requesting url ends with min.js or .js
        /// </summary>
        public bool CompressAllJS { get; init; } = false;

        private VueMiddleware _middleWare;
        internal VueMiddleware VueMiddleware { set { _middleWare = value; } }

        /// <summary>
        /// called when an assemblyloadcontext needs to be unloaded, this will remove all references to 
        /// that load context to allow for an unload
        /// </summary>
        /// <param name="context">The assembly context being unloaded</param>
        public void UnloadAssemblyContext(AssemblyLoadContext context)
        {
            UnloadAssemblyContext(context.Name);
        }

        /// <summary>
        /// called when an assembly context needs to be unloaded without providing the context but its name
        /// instead
        /// </summary>
        /// <param name="contextName">The name of the assembly load context to unload</param>
        public void UnloadAssemblyContext(string contextName)
        {
            _middleWare.UnloadAssemblyContext(contextName);
        }

        /// <summary>
        /// Called when a new Assembly Load Context has been added
        /// </summary>
        /// <param name="contextName">The name of the context that was added</param>
        public void AsssemblyLoadContextAdded(string contextName)
        {
            _middleWare.AsssemblyLoadContextAdded(contextName);
        }

        /// <summary>
        /// Called when a new Assembly Load Context has been added
        /// </summary>
        /// <param name="alc">The assembly load context that was added</param>
        /// <exception cref="ModelValidationException">Houses a set of exceptions if any newly loaded models fail validation</exception>
        public void AsssemblyLoadContextAdded(AssemblyLoadContext alc)
        {
            AsssemblyLoadContextAdded(alc.Name);
        }

        ///<summary>
        ///called when a new assembly has been loaded in the case of dynamic loading, in order 
        ///to rescan for all new model types and add them accordingly.
        ///</summary>
        public void AssemblyAdded()
        {
            _middleWare.AssemblyAdded();
        }
    }

    /// <summary>
    /// This is the middleware defined to intercept requests coming in and handle them when necessary
    /// </summary>
    public class VueMiddleware : IDisposable
    {
        private readonly VueMiddlewareOptions _options;
        /// <summary>
        /// The Options that were supplied to construct the VueMiddleware
        /// </summary>
        public VueMiddlewareOptions Options => _options;
        private readonly ModelRequestHandler _modelHandler;
        private readonly MessagesHandler[] _messageHandlers;
        private readonly VueFilesHandler[] _vueFileHandlers;
        private readonly string _compressedCore;
        private readonly IMemoryCache _cache;

        /// <summary>
        /// default constructor as per dotnet standards
        /// </summary>
        /// <param name="next">next delegate call as per dotnet standards</param>
        /// <param name="options">the supplied options for creating the middle ware</param>
        /// <param name="cache">optionally supplied caching mechanism to use</param>
        public VueMiddleware(RequestDelegate next, VueMiddlewareOptions options, IMemoryCache cache=null)
        {
            if ((options.VueFilesOptions!=null||options.MessageOptions!=null) && options.FileProvider==null)
                throw new ArgumentNullException(nameof(options),$"{nameof(options.FileProvider)} must be provided");
            var log = options.LogWriter;
            options.VueMiddleware=this;

            _cache = cache ?? new MemoryCache(new MemoryCacheOptions() { });

            StreamReader sr = new(typeof(JSHandler).Assembly.GetManifestResourceStream("VueJSMVCDotNet.Handlers.Model.JSGenerators.core.js"));
            var builder = new StringBuilder();
            builder.Append(@$"import * as vue from ""{options.VueImportPath}"";
const securityHeaders = {{");

            if (options.VueModelsOptions!=null && options.VueModelsOptions.SecurityHeaders!=null)
            {
                foreach (string key in options.VueModelsOptions.SecurityHeaders)
                    builder.Append($"'{key.Replace("'", "\\'")}':null,");
                builder.Length-=1;
            }

            builder.AppendLine("};");
            builder.AppendLine(sr.ReadToEnd());
            _compressedCore = JSMinifier.Minify(builder.ToString());
            sr.Close();

            _options = options;
            next ??= new RequestDelegate(NotFound);
            if (options.VueFilesOptions!=null)
            {
                var fileHandlers = new List<VueFilesHandler>();
                foreach (var url in options.VueFilesOptions.BaseURL.Split(';'))
                {
                    if (!string.IsNullOrEmpty(url.Trim()))
                    {
                        var handler = new VueFilesHandler(
                            options.FileProvider, 
                            url,  
                            options.VueImportPath, 
                            options.VueLoaderImportPath, 
                            options.CoreJSImport??options.CoreJSURL,
                            options.CompressAllJS,
                            (url) => (_modelHandler==null ? false : _modelHandler.HandlesJSPath(url)),
                            next, 
                            _cache,
                            log
                        );
                        fileHandlers.Add(handler);
                        next = new RequestDelegate(handler.ProcessRequest);
                    }
                }
                _vueFileHandlers = fileHandlers.ToArray();
            }
            if (options.MessageOptions!=null)
            {
                var messageHandlers = new List<MessagesHandler>();
                foreach (var url in options.MessageOptions.BaseURL.Split(';'))
                {
                    if (!string.IsNullOrEmpty(url.Trim()))
                    {
                        var handler = new MessagesHandler(
                            options.FileProvider, 
                            url,
                            log,
                            options.CompressAllJS, 
                            next,
                            _cache, 
                            options.CoreJSImport??options.CoreJSURL, 
                            options.VueImportPath
                        );
                        messageHandlers.Add(handler);
                        next = new RequestDelegate(handler.ProcessRequest);
                    }
                }
                _messageHandlers=messageHandlers.ToArray();
            }
            if (options.VueModelsOptions!=null)
            {
                _modelHandler = new ModelRequestHandler(log, options.VueModelsOptions.BaseURL, options.VueModelsOptions.IgnoreInvalidModels, options.VueImportPath,
                    options.CoreJSImport??options.CoreJSURL,
                options.VueModelsOptions.SessionFactory,options.CompressAllJS, next, _cache);
            }
        }

        /// <summary>
        /// Disposable implementation to allow for cleanup and proper disposal
        /// </summary>
        public void Dispose()
        {
            _modelHandler?.Dispose();
            if (_messageHandlers!=null)
            {
                for (int x = 0; x< _messageHandlers.Length; x++)
                    _messageHandlers[x].Dispose();
            }
            if (_vueFileHandlers!=null)
            {
                for(int x=0;x< _vueFileHandlers.Length; x++)
                    _vueFileHandlers[x].Dispose();
            }
            _cache.Dispose();
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// the dotnet required method for produce a dependency injectable middle ware that all calls go through
        /// </summary>
        /// <param name="context">the current httpcontext</param>
        /// <returns>a task</returns>
        public async Task InvokeAsync(HttpContext context)
        {
            if (string.Equals(context.Request.Method,"GET",StringComparison.InvariantCultureIgnoreCase)
                && context.Request.Path.Equals(new PathString(_options.CoreJSURL)))
            {
                context.Response.ContentType="text/javascript";
                context.Response.StatusCode= 200;
                await context.Response.WriteAsync(_compressedCore);
            }else if (_modelHandler!=null)
                await _modelHandler.ProcessRequest(context);
            else if (_messageHandlers!=null)
                await _messageHandlers[0].ProcessRequest(context);
            else
                await _vueFileHandlers[0].ProcessRequest(context);
        }
        private async Task NotFound(HttpContext context)
        {
            context.Response.StatusCode = 404;
            await context.Response.WriteAsync("Not Found");
        }
        internal void UnloadAssemblyContext(string contextName)
        {
            _modelHandler?.UnloadAssemblyContext(contextName);
        }

        internal void AssemblyAdded()
        {
            _modelHandler?.AssemblyAdded();
        }

        internal void AsssemblyLoadContextAdded(string contextName)
        {
            _modelHandler?.AsssemblyLoadContextAdded(contextName);
        }
    }

    /// <summary>
    /// Static Middleware Extension to allow for Dependency Inject to occur, allowing for app.UseVueHandler
    /// in order to cause the library to be active in the request process
    /// </summary>
    [ExcludeFromCodeCoverage()]
    public static class VueMiddlewareExtension
    {
        /// <summary>
        /// call based on dotnet standards for middleware dependency injection
        /// </summary>
        /// <param name="builder">the application builder</param>
        /// <param name="options">the options used to define the middle ware settings</param>
        /// <returns>the application builder with the middleware setup</returns>
        public static IApplicationBuilder UseVueMiddleware(
            this IApplicationBuilder builder,
            VueMiddlewareOptions options) => builder.UseMiddleware<VueMiddleware>(options);
    }
}
